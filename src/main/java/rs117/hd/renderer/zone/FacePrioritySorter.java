/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.renderer.zone;

import java.util.Arrays;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;

import static rs117.hd.renderer.zone.WorldViewContext.ALPHA_ZSORT_SQ;
import static rs117.hd.renderer.zone.Zone.VERT_SIZE;
import static rs117.hd.utils.HDUtils.ceilPow2;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
final class FacePrioritySorter {
	private static final int MAX_VERTEX_COUNT = 6500;
	private static final int MAX_FACE_COUNT = 8192;
	private static final int MAX_DIAMETER = 6000;
	private static final int MAX_FACES_PER_PRIORITY = 4000;
	private static final int PRIORITY_COUNT = 12;

	private static final int[] BASE_PRIORITY_LUT = new int[PRIORITY_COUNT];

	static {
		for (int i = 0; i < PRIORITY_COUNT; i++)
			BASE_PRIORITY_LUT[i] = i * MAX_FACES_PER_PRIORITY;
	}

	public final float[] modelProjected = new float[MAX_VERTEX_COUNT * 3];

	private final int[] orderedFaces = new int[PRIORITY_COUNT * MAX_FACES_PER_PRIORITY];
	private final int[] numOfPriority = new int[PRIORITY_COUNT];
	private final int[] eq10 = new int[MAX_FACES_PER_PRIORITY];
	private final int[] eq11 = new int[MAX_FACES_PER_PRIORITY];
	private final int[] lt10 = new int[PRIORITY_COUNT];

	private final int[] zsortHead = new int[MAX_DIAMETER];
	private final int[] zsortTail = new int[MAX_DIAMETER];
	private final int[] zsortNext = new int[MAX_FACE_COUNT];

	void sortModelFaces(
		SortedFaces sortedFaces,
		SortedFaces unsortedFaces,
		Model model
	) {
		final int diameter = model.getDiameter();
		if (diameter <= 0 || diameter >= MAX_DIAMETER)
			return;

		final int faceCount = model.getFaceCount();
		final int radius = model.getRadius();

		sortedFaces.reset();
		unsortedFaces.reset();

		unsortedFaces.ensureCapacity(faceCount);
		int minFz = diameter, maxFz = 0;

		Arrays.fill(zsortHead, 0, diameter, -1);
		Arrays.fill(zsortTail, 0, diameter, -1);

		final int[] indices1 = model.getFaceIndices1();
		final int[] indices2 = model.getFaceIndices2();
		final int[] indices3 = model.getFaceIndices3();
		final int[] faceColors3 = model.getFaceColors3();
		for (int i = 0; i < faceCount; ++i) {
			if (faceColors3[i] == -2)
				continue;

			final int offsetA = indices1[i] * 3;
			final float aX = modelProjected[offsetA];
			final float aY = modelProjected[offsetA + 1];

			final int offsetB = indices2[i] * 3;
			final float bX = modelProjected[offsetB];
			final float bY = modelProjected[offsetB + 1];

			final int offsetC = indices3[i] * 3;
			final float cX = modelProjected[offsetC];
			final float cY = modelProjected[offsetC + 1];

			// Back-face culling
			if ((aX - bX) * (cY - bY) - (cX - bX) * (aY - bY) <= 0) {
				unsortedFaces.putFace(i);
				continue;
			}

			final int aZ = (int) modelProjected[offsetA + 2];
			final int bZ = (int) modelProjected[offsetB + 2];
			final int cZ = (int) modelProjected[offsetC + 2];
			final int fz = clamp(radius + (aZ + bZ + cZ) / 3, 0, diameter - 1);

			if (zsortTail[fz] == -1) {
				zsortHead[fz] = zsortTail[fz] = i;
				zsortNext[i] = -1;
			} else {
				int lastFace = zsortTail[fz];
				zsortNext[lastFace] = i;
				zsortNext[i] = -1;
				zsortTail[fz] = i;
			}

			minFz = min(minFz, fz);
			maxFz = max(maxFz, fz);
		}

		sortedFaces.ensureCapacity(faceCount - unsortedFaces.length);
		final byte[] priorities = model.getFaceRenderPriorities();

		if (priorities == null) {
			for (int i = maxFz; i >= minFz; --i) {
				for (int f = zsortHead[i]; f != -1; f = zsortNext[f]) {
					if(f < faceCount)
						sortedFaces.putFace(f);
				}
			}
			return;
		}

		Arrays.fill(numOfPriority, 0);
		Arrays.fill(lt10, 0);

		for (int i = maxFz; i >= minFz; --i) {
			for (int f = zsortHead[i]; f != -1; f = zsortNext[f]) { ;
				final int pri = priorities[f];
				final int idx = numOfPriority[pri]++;

				orderedFaces[BASE_PRIORITY_LUT[pri] + idx] = f;

				if (pri < 10)
					lt10[pri] += i;
				else if (pri == 10)
					eq10[idx] = i;
				else
					eq11[idx] = i;
			}
		}

		int avg12 = (numOfPriority[1] + numOfPriority[2]) > 0
			? (lt10[1] + lt10[2]) / (numOfPriority[1] + numOfPriority[2]) : 0;

		int avg34 = (numOfPriority[3] + numOfPriority[4]) > 0
			? (lt10[3] + lt10[4]) / (numOfPriority[3] + numOfPriority[4]) : 0;

		int avg68 = (numOfPriority[6] + numOfPriority[8]) > 0
			? (lt10[6] + lt10[8]) / (numOfPriority[6] + numOfPriority[8]) : 0;

		int drawnFaces = 0;
		int dynPri = 10;
		int numDynFaces = numOfPriority[10];
		int dynBase = BASE_PRIORITY_LUT[10];
		int[] dynDist = eq10;

		int currFaceDistance =
			drawnFaces < numDynFaces ? dynDist[drawnFaces] : -1000;

		for (int pri = 0; pri < 10; ++pri) {
			while ((pri == 0 && currFaceDistance > avg12)
				   || (pri == 3 && currFaceDistance > avg34)
				   || (pri == 5 && currFaceDistance > avg68)) {
				sortedFaces.putFace(orderedFaces[dynBase + drawnFaces++]);

				if (drawnFaces == numDynFaces && dynPri == 10) {
					dynPri = 11;
					drawnFaces = 0;
					numDynFaces = numOfPriority[11];
					dynBase = BASE_PRIORITY_LUT[11];
					dynDist = eq11;
				}

				currFaceDistance =
					drawnFaces < numDynFaces ? dynDist[drawnFaces] : -1000;
			}

			sortedFaces.putFaces(
				orderedFaces,
				BASE_PRIORITY_LUT[pri],
				numOfPriority[pri]
			);
		}

		while (currFaceDistance != -1000) {
			sortedFaces.putFace(orderedFaces[dynBase + drawnFaces++]);

			if (drawnFaces == numDynFaces && dynPri == 10) {
				dynPri = 11;
				drawnFaces = 0;
				numDynFaces = numOfPriority[11];
				dynBase = BASE_PRIORITY_LUT[11];
				dynDist = eq11;
			}

			currFaceDistance =
				drawnFaces < numDynFaces ? dynDist[drawnFaces] : -1000;
		}
	}

	void sortStaticModelFacesWithPriority(
		Zone.AlphaModel m,
		int yawCos, int yawSin,
		int pitchCos, int pitchSin
	) {
		final int radius = m.radius;
		final int diameter = 1 + radius * 2;
		if (diameter >= MAX_DIAMETER)
			return;

		final int faceCount = m.packedFaces.length;

		Arrays.fill(zsortHead, 0, diameter, -1);
		Arrays.fill(zsortTail, 0, diameter, -1);

		int minFz = diameter, maxFz = 0;

		for (int i = 0; i < faceCount; ++i) {
			final int packed = m.packedFaces[i];
			final int x = packed >> 21;
			final int y = (packed << 11) >> 22;
			final int z = (packed << 21) >> 21;

			int fz = ((z * yawCos - x * yawSin) >> 16);
			fz = ((y * pitchSin + fz * pitchCos) >> 16) + radius;
			fz = clamp(fz, 0, diameter - 1);

			if (zsortTail[fz] == -1) {
				zsortHead[fz] = zsortTail[fz] = i;
				zsortNext[i] = -1;
			} else {
				int lastFace = zsortTail[fz];
				zsortNext[lastFace] = i;
				zsortNext[i] = -1;
				zsortTail[fz] = i;
			}

			minFz = min(minFz, fz);
			maxFz = max(maxFz, fz);
		}

		final int start = m.startpos / (VERT_SIZE >> 2);
		final byte[] pri = m.renderPriorities;

		Arrays.fill(numOfPriority, 0);
		int minPri = PRIORITY_COUNT, maxPri = 0;

		for (int i = maxFz; i >= minFz; --i) {
			for (int face = zsortHead[i]; face != -1; face = zsortNext[face]) {
				byte p = pri[face];
				int offset = numOfPriority[p]++;

				if (offset == 0) {
					minPri = min(minPri, p);
					maxPri = max(maxPri, p);
				}

				orderedFaces[BASE_PRIORITY_LUT[p] + offset] = face;
			}
		}

		for (int p = minPri; p <= maxPri; ++p) {
			final int cnt = numOfPriority[p];
			final int base = BASE_PRIORITY_LUT[p];

			for (int i = 0; i < cnt; ++i) {
				if(m.sortedFacesLen >= m.sortedFaces.length)
					break;

				final int sortedOffset = m.sortedFacesLen;
				final int faceStart = orderedFaces[base + i] * 3 + start;
				m.sortedFaces[sortedOffset] = faceStart;
				m.sortedFaces[sortedOffset + 1] = faceStart + 1;
				m.sortedFaces[sortedOffset + 2] = faceStart + 2;
				m.sortedFacesLen += 3;
			}
		}
	}

	void sortFarStaticModelFacesByDistance(
		Zone.AlphaModel m,
		int yawCos, int yawSin,
		int pitchCos, int pitchSin
	) {
		final int radius = m.radius;
		final int diameter = 1 + radius * 2;
		if (diameter >= MAX_DIAMETER)
			return;

		final int faceCount = m.packedFaces.length;

		final float distFrac = saturate(m.dist / (float) ALPHA_ZSORT_SQ);
		final int buckets = clamp(
			ceilPow2((int) ((float) diameter * (1.0f - distFrac))),
			8,
			diameter
		);

		Arrays.fill(zsortHead, 0, buckets, -1);
		Arrays.fill(zsortTail, 0, buckets, -1);

		int minBucket = buckets, maxBucket = 0;

		for (int i = 0; i < faceCount; ++i) {
			final int packed = m.packedFaces[i];
			final int x = packed >> 21;
			final int y = (packed << 11) >> 22;
			final int z = (packed << 21) >> 21;

			int fz = ((z * yawCos - x * yawSin) >> 16);
			fz = ((y * pitchSin + fz * pitchCos) >> 16) + radius;

			final int bucket = floor(saturate(fz / (float) diameter) * buckets);
			if (zsortTail[fz] == -1) {
				zsortHead[fz] = zsortTail[fz] = i;
				zsortNext[i] = -1;
			} else {
				int lastFace = zsortTail[fz];
				zsortNext[lastFace] = i;
				zsortNext[i] = -1;
				zsortTail[fz] = i;
			}

			minBucket = min(minBucket, bucket);
			maxBucket = max(maxBucket, bucket);
		}

		final int start = m.startpos / (VERT_SIZE >> 2);

		for (int b = maxBucket; b >= minBucket; --b) {
			for (int face = zsortHead[b]; face != -1; face = zsortNext[face]) {
				if(m.sortedFacesLen >= m.sortedFaces.length)
					break;

				final int sortedOffset = m.sortedFacesLen;
				final int faceStart = face * 3 + start;
				m.sortedFaces[sortedOffset] = faceStart;
				m.sortedFaces[sortedOffset + 1] = faceStart + 1;
				m.sortedFaces[sortedOffset + 2] = faceStart + 2;
				m.sortedFacesLen += 3;
			}
		}
	}

	public static final class SortedFaces {
		public int[] faces = new int[16];
		public int length;

		public SortedFaces reset() {
			length = 0;
			return this;
		}

		private SortedFaces ensureCapacity(int count) {
			if (length + count > faces.length)
				 faces = Arrays.copyOf(faces, ceilPow2(length + count));
			return this;
		}

		private void putFace(int f) {
			if (length < faces.length)
				faces[length++] = f;
		}

		private void putFaces(int[] indices, int offset, int count) {
			ensureCapacity(count);
			System.arraycopy(indices, offset, faces, length, count);
			length += count;
		}
	}
}
